@namespace iPath.Blazor.Componenents.Shared.Coding

<MudTreeView T="CodeDisplay" Items="@TreeItems" @ref="_treeView"
             SelectionMode="SelectionMode.MultiSelection"
             AutoSelectParent="true"
             FilterFunc="MatchesName"
             CheckBoxColor="Color.Info"
             @bind-SelectedValues="Values"
             @bind-SelectedValues:after="OnValueChanged"
             Hover="true" Dense="true" Color="Color.Tertiary">
    <ItemTemplate>
        <MudTreeViewItem T="CodeDisplay" Items="@context.Children"
                         @bind-Expanded="@context.Expanded"
                         Value="@context.Value" Text="@context.Value.ToDisplay()" />
    </ItemTemplate>
</MudTreeView>

@code {
    [Parameter]
    public List<TreeItemData<CodeDisplay>> TreeItems { get; set; } = [];

    IReadOnlyCollection<CodeDisplay> Values { get; set; } = [];

    [Parameter]
    public IReadOnlyCollection<CodeDisplay> Selection
    {
        get => field;
        set
        {
            field = value;
            Values = value;
            StateHasChanged();
        }
    }

    [Parameter]
    public EventCallback<IReadOnlyCollection<CodeDisplay>> SelectionChanged { get; set; }


    async Task OnValueChanged()
    {
        // Build a lookup of selected codes
        var selectedCodes = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        if (Values is not null)
        {
            foreach (var v in Values)
            {
                if (v?.Code is not null)
                    selectedCodes.Add(v.Code);
            }
        }

        var _selection = new List<CodeDisplay>();

        // Recursive helper: determines whether all nodes in the subtree are selected.
        bool NodeFullySelected(ITreeItemData<CodeDisplay> node)
        {
            var children = node.Children;
            if (children is null)
            {
                // leaf node
                return node.Value?.Code is not null && selectedCodes.Contains(node.Value.Code);
            }

            bool hadChild = false;
            foreach (var child in children)
            {
                hadChild = true;
                if (!NodeFullySelected(child))
                    return false;
            }

            // no children -> treat as leaf
            if (!hadChild)
                return node.Value?.Code is not null && selectedCodes.Contains(node.Value.Code);

            // all children fully selected
            return true;
        }

        // Traverse and collect: if a node's entire subtree is selected, add only the parent and skip children.
        void Traverse(ITreeItemData<CodeDisplay> node)
        {
            if (NodeFullySelected(node))
            {
                if (node.Value is not null)
                    _selection.Add(node.Value);
                return;
            }

            // If node itself was selected (but not all children), include it as well.
            if (node.Value is not null && selectedCodes.Contains(node.Value.Code ?? string.Empty))
                _selection.Add(node.Value);

            if (node.Children is not null)
            {
                foreach (var child in node.Children)
                    Traverse(child);
            }
        }

        if (TreeItems is not null)
        {
            foreach (var root in TreeItems)
            {
                // TreeItemData implements ITreeItemData<T>, so cast is safe
                Traverse(root);
            }
        }

        // Propagate the collapsed selection (parents replacing fully-selected children)
        Selection = _selection;
        await SelectionChanged.InvokeAsync(Selection);
    }


    MudTreeView<CodeDisplay> _treeView;
    string _searchPhrase;

    public async Task Search(string searchPhrase)
    {
        _searchPhrase = searchPhrase;
        await _treeView.FilterAsync();
    }

    private Task<bool> MatchesName(ITreeItemData<CodeDisplay> item)
    {
        if (string.IsNullOrEmpty(item.Text))
        {
            return Task.FromResult(false);
        }

        return Task.FromResult(item.Text.Contains(_searchPhrase, StringComparison.OrdinalIgnoreCase));
    }
}
