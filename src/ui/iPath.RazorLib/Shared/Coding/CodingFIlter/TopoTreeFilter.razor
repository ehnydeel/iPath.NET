@using Microsoft.Extensions.DependencyInjection
@using iPath.Application.Fhir
@using iPath.Domain.Entities.Base

@namespace iPath.Blazor.Componenents.Shared.Coding

<MudPaper Elevation="0">
    <MudStack Row AlignItems="AlignItems.End">
        <h3>@T["Body site filter (icd-o)"]</h3>
        <MudSpacer />
        <MudTextField T="string" Label="Search" Adornment="Adornment.Start"
                      AdornmentIcon="@Icons.Material.Filled.Search" Variant="Variant.Outlined" Margin="Margin.Dense"
                      TextChanged="Search" Immediate="true" Clearable="true" />

    </MudStack>
    <MudDivider />
    @if (true || RendererInfo.IsInteractive)
    {
        <MudTreeView T="CodeDisplay" Items="@BodySiteCodes" @ref="_treeView"
                     SelectionMode="SelectionMode.MultiSelection"
                     FilterFunc="MatchesName"
                     CheckBoxColor="Color.Info"
                     MaxHeight="400px"
                     @bind-SelectedValues="SelectedValues"
                     Hover="true" Dense="true" Color="Color.Tertiary">
            <ItemTemplate>
                <MudTreeViewItem T="CodeDisplay" Items="@context.Children"
                                 Value="@context.Value" Text="@context.Value.ToDisplay()" />
            </ItemTemplate>
        </MudTreeView>

        <div style="border: 1px; margin-top: 8px; font-size: 0.7em;">
            <strong>selection: </strong> @selStr<br />
            <strong>filter: </strong> @filterStr
        </div>
    }
    else
    {
        <MudSkeleton Height="200px" />
    }
</MudPaper>

@inject IServiceProvider sp;

    @code {
    [Parameter]
    public ConceptFilter? Filter { get; set; }

    [Parameter]
    public EventCallback<ConceptFilter?> FilterChanged { get; set; }


    MudTreeView<CodeDisplay> _treeView;
    IReadOnlyCollection<CodeDisplay> SelectedValues { get; set; } = [];

    string selStr => SelectedValues is null ? "--" : string.Join(", ", SelectedValues.Select(x => x.Code).ToArray());
    string filterStr => Filter?.Concetps is null ? "--" : string.Join(", ", Filter.Concetps.Select(x => x.Code).ToArray());

    public List<TreeItemData<CodeDisplay>> BodySiteCodes { get; private set; } = new();


    const string system = "icdo";
    const string vsid = "icdo-topo";



    CodingService _coding;
    ValueSetDisplay _valueset;
    protected override async Task OnInitializedAsync()
    {
        _coding = sp.GetRequiredKeyedService<CodingService>(system);
        var _loader = sp.GetRequiredService<IFhirDataLoader>();

        // TODO: initilize in DI startup
        await _coding.LoadCodeSystem();
        await _coding.LoadValueSet(vsid);
        _valueset = _coding.GetValueSetDisplay(vsid);

        // if only one root node => start with it's childrend
        // TODO: write an extension that finds the first node with more than 1 child
        if (_valueset.DisplayTree.Count == 1)
        {
            BodySiteCodes = _valueset.DisplayTree.First().Children.ToTreeView();
        }
        else
        {
            BodySiteCodes = _valueset.DisplayTree.ToTreeView();
        }

        LoadFilter();
    }

    protected override void OnParametersSet()
    {
        LoadFilter();
    }


    private void LoadFilter()
    {
        if (Filter is not null && _valueset is not null)
        {
            var mysel = new List<CodeDisplay>();
            foreach (var code in Filter.Concetps)
            {
                var expanded = _coding.GetChildCodes(code.Code, true);
                foreach (var x in expanded.ChildCodes)
                {
                    mysel.Add(_valueset.GetByCode(x));
                }
            }
            SelectedValues = mysel;
        }
        else
        {
            SelectedValues = new List<CodeDisplay>();
        }
        StateHasChanged();
    }

    public void SaveFilter()
    {
        // Build a lookup of selected codes
        var selectedCodes = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        if (SelectedValues is not null)
        {
            foreach (var v in SelectedValues)
            {
                if (v?.Code is not null)
                    selectedCodes.Add(v.Code);
            }
        }

        var _selection = new List<CodeDisplay>();

        // Recursive helper: determines whether all nodes in the subtree are selected.
        bool NodeFullySelected(ITreeItemData<CodeDisplay> node)
        {
            var children = node.Children;
            if (children is null)
            {
                // leaf node
                return node.Value?.Code is not null && selectedCodes.Contains(node.Value.Code);
            }

            bool hadChild = false;
            foreach (var child in children)
            {
                hadChild = true;
                if (!NodeFullySelected(child))
                    return false;
            }

            // no children -> treat as leaf
            if (!hadChild)
                return node.Value?.Code is not null && selectedCodes.Contains(node.Value.Code);

            // all children fully selected
            return true;
        }

        // Traverse and collect: if a node's entire subtree is selected, add only the parent and skip children.
        void Traverse(ITreeItemData<CodeDisplay> node)
        {
            if (NodeFullySelected(node))
            {
                if (node.Value is not null)
                    _selection.Add(node.Value);
                return;
            }

            // If node itself was selected (but not all children), include it as well.
            if (node.Value is not null && selectedCodes.Contains(node.Value.Code ?? string.Empty))
                _selection.Add(node.Value);

            if (node.Children is not null)
            {
                foreach (var child in node.Children)
                    Traverse(child);
            }
        }

        if (BodySiteCodes is not null)
        {
            foreach (var root in BodySiteCodes)
            {
                // TreeItemData implements ITreeItemData<T>, so cast is safe
                Traverse(root);
            }
        }


        if (_selection.IsEmpty())
        {
            Filter = null;
        }
        else
        {
            Filter ??= new();
            Filter.Concetps = _selection.ToConcept(_coding.CodeSystemUrl).ToList();
        }

        StateHasChanged();
    }


    async Task Search(string searchPhrase)
    {
        _searchPhrase = searchPhrase;
        await _treeView.FilterAsync();
    }

    string _searchPhrase;

    private Task<bool> MatchesName(ITreeItemData<CodeDisplay> item)
    {
        if (string.IsNullOrEmpty(item.Text))
        {
            return Task.FromResult(false);
        }

        return Task.FromResult(item.Text.Contains(_searchPhrase, StringComparison.OrdinalIgnoreCase));
    }
    private void OnChanged(IReadOnlyCollection<CodeDisplay> args)
    {
        Console.Write(".");
        StateHasChanged();
    }
}
